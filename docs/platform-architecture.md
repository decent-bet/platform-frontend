## Decent.bet Platform architecture overview

This document acts as on overview of the Decent.bet platform's architecture.
It outlines the different components that work together to make 
up the platform. Note that the platform is in development and certain
points outlined below may change over time. If you do notice any discrepancy
with an implementation, don't hesitate to create a PR.

The Decent.bet platform to start with offers an initial house operated by the 
Decent.bet team that will offer various casino games and sports betting. 
In the long term, token holders on the platform would be able to initially 
buy into new houses that're issued by the Decent.bet house.

After an initial house buyout, interested 3rd parties would be able to purchase houses 
from the platform by bidding on the house and essentially offering a higher rate
than what was initially paid for the house - distributing profit among all investors
of the house.

The platform is split into the following components:

* Houses
* House offerings
* House Lotteries
* Betting Providers
* Sports Oracles
* Game Channel Managers

### The House

The house acts as a hub that interconnects different **house offerings**, provides a 
**house lottery** and offers purchasable house credits to DBET token holders. 
House shares lock up investors' DBETs into the house and is used by house offerings 
to financially back their games/bets.

#### Authorized Addresses

The owner of a house can add ***authorized addresses*** to the house which 
would effectively give the addresses permission to make the following changes to the
house:

* Allocate tokens to house offerings for the next session.
* Withdrawing previous session tokens from house offerings.
* Depositing allocated % of tokens to house offerings.
* Pick house lottery winners.
* Update the winning lottery ticket from the house lottery contract.
* Begin the next session after the previous session has expired and all house 
  offerings have had tokens allocated to them.
  
#### House Credits

Token holders are allowed to lock up tokens for a session in the house in return
for house credits. At the end of the session, users can swap their house credits for 
a split proportional to the final balance of the house at the end of a session.

#### Sessions

A session is a period of 12 weeks during which the house tracks games/bets placed on
all house offerings and distributes all profits generated by the house to house credit
holders. Each session is essentially split into 3 periods:

1. Two weeks before a regular session begins - excluding session zero, users 
are allowed to purchase credits for the next session. For every 1000 credits purchased
by an address, the address gets an entry into the Decent.bet lottery. Each address
is allowed to get up to 5 tickets.

2. After the credit purchasing period is completed, the house allocates tokens raised 
to all house offerings available on the platform before the next session begins. 
A 12 week period now takes place during which house offerings offer their 
games/bets to users of the platform.

3. At the end of the 12 week period, authorized addresses of the house will be able to
withdraw the previous session tokens from house offerings after a period of 2 days. 
After a period of 4 days from the end of a session - to account for bets that 
may cross the 12 week period, house credit holders will now allow be able to 
liquidate their credits or roll a portion of them over to the next session. 
At this point in time, authorized addresses will also have to pick lottery 
winners for the previous session.

#### Session Zero

At the start of the Decent.bet house, the initial session consists of a single period
during which users are given a 2 week period to solely purchase credits within the 
house after which the house allocates token to it's offerings and begins Session 1.
    
### House Offerings

Casino games or betting providers offered by the house are termed as 
house offerings within the Decent.bet platform. House offerings allow users to 
deposit tokens within it's contract for each session. 

Deposited tokens can be withdrawn at any time by users for the current or previous 
session(s).

House offerings are meant to follow the abstract interface present in the 
HouseOffering contract which provides the following variables and functions.

1. name - string - The name of the House Offering. Would be defined in the constructor 
of an offering.

2. isHouseOffering - bool - only for validation purposes for the house to ensure an incorrect
address isn't added as an house offering.

3. houseDeposit(uint amount, uint session) - Allows the house to deposit tokens into 
the offering for a session.

4. withdrawPreviousSessionTokens() - Allows the house to withdraw tokens for the 
previous session.

5. deposit(uint amount) - Allows users to deposit tokens into the offering for the 
current session.

6. withdraw(uint amount, uint session) - Allows users to withdraw tokens from the
offering for any given session.

7. balanceOf(address _address, uint session) - View the balance available for the user
for a particular session.

8. setSession(uint session) - Allows the house to change the session at the end 
of the previous session. Note that the house can only call this after the 
previous session has ended.

### House Lottery

The house lottery doesn't come under the House Offering category of contracts and 
is instead solely used to pick a winner at the end of a session based on the total
number of tickets distributed by the house. The contract makes use of oraclize
to pick a random 7 digit number using WolfRamAlpha as a data source.

The random number pushed in by oraclize is then used to calculate the winning ticket
number within the range of ticket numbers distributed using the following formula

    ((number - 1000000) * (number of tickets + 1)) / 8999999
    
For example, if the 7 digit number returned via oraclize turns out to be
3,121,467 and the number of lottery tickets distributed was 389. The random number
in range would be

    ((3121367 - 1000000) * (389 + 1)) / 8999999
   
This finally leads to a random number between 0 and ***number of tickets***, which in
this case adds up to 91. The random number generated would be used by the house 
to determine the winning ticket and distribute 5% of the previous session winnings 
to the address that maps to the winning ticket on the house
contract.

### Betting Providers

Betting providers are house offerings that connect with Sports Oracles and allow
users to place bets on games that are pushed out by them. Betting providers
can push odds for games that're available and allow users to bet on the odds
while providing payouts by the contract based on the outcome provided by
the sports oracle connected to it.

There are 4 different kinds of bets that can be made with a betting provider:

1. Spread
2. Moneyline
3. Total
4. Team Total

All bets rely on American format odds (+100/-100) since it's the simplest to deal
with in Solidity.

Betting providers need
to be accepted by sports oracles to allow oracles to push outcomes of games into
the provider. This can be done by either requesting the oracle to add the provider or
paying an ***acceptance cost*** which essentially allows providers to be 
automatically be accepted by an oracle by simply paying a fee.

Once an oracle accepts a provider, only the oracle would be able to update
outcomes for games within the provider contract. If a betting provider prefers
to push in game updates themselves, they'd have to setup their own sports oracle 
and use it solely for their betting provider contract.

Since betting provider contracts are house offerings, users will need to deposit 
tokens into the provider contract for the current session before placing bets 
on games offered by the provider.

Stats of each session is tracked by the contract, including the following
metrics

* Total bet amount
* Total payouts
* Total deposited
* Total profit
* Total withdrawn

### Sports Oracles

All sports betting on the Decent.bet platform require data sources to provide 
game fixtures and outcomes. These data sources are provided in the form 
of sports oracle contracts. Sports oracle work synergistically with Betting 
Providers - providing them with fixture and outcome data.

Sports oracles can accept betting providers to avail of the oracle's services for
no charge or a free. Providers can then request oracles to provide outcomes for games,
these outcomes can also be charged a fee for by the oracle giving data providers
an additional source of revenue.

Note: A penalty for non-reporting sports oracles would aid the entire platform and 
would be a necessary and beneficial addition to the sports oracle contract.
 
### Casino

The Decent.bet casino will utilize State Channels to ensure the casino experience 
isn't hampered by impractically slow block times that're inevitable with
blockchains as successful and adopted as Ethereum. 

### State Channel Managers

All games will consist of state channel manager contracts which would essentially
act as a cryptographically verifiable escrow between the house and player holding 
and distribute DBETs for both parties while they complete their game off-chain. 

At any time, if either party would like to close the channel, a signed message
of a hash generated based on the data generated based on the last game moves of 
the opponent would be used to prove that the opponent did play until the last turn.

All RNG verification would happen off-chain by both parties as well to ensure the
random numbers generated using a standardized and mutually agreed upon 
seed-able PRNG library are correct. If at any point, a user is alerted that the 
opponent sent an incorrect hash, the channel can be closed with the last legitimate 
signed messages provided by the user and opponent.

### Slots

Just like every game to be built on the platform, the
[Slots contract](https://github.com/decent-bet/platform-frontend/contracts/Casino/Slots/SlotsChannelManager.sol) 
functions as a State Channel Manager while also being a House Offering.
The reels used by are pre-defined and hardcoded within the contract.

Just like any other house offering, users are supposed to deposit within the contract
for the current session before creating channels to play the games.

When a channel is created, users are allowed to choose the amount of DBETs they'd
like to deposit into the channel. At the moment, they're allowed to deposit between 
100 and 1000 DBETs. A cap is necessary in this scenario to ensure all DBETs 
allocated to slots don't get locked up into a few channels.

After a channel is created, the user then generates an initial random number 
which's then AES-256 encrypted using a hash of the contract address signed by 
the user's address as the key. The resulting string is then SHA-256 hashed 1000 times
and the final hash is then sent in a transaction to the contract along with the 
encrypted random string and the amount to deposit in DBETs. The random encrypted 
string is necessary for users to recreate the channels' state and continue 
at a later time.

When a deposit is made into a channel by the user, the house' slots channel 
manager module on the backend receives a LogChannelDeposit event and performs 
various checks (for balances, DoS attempts etc.) before sending a transaction 
to deposit DBETs and activate the channel. The house also generates
a similar encrypted string and final hash which's sent to the contract to rebuild
state if needed in the future.

After the Activation event is received from the network, both user and house
can begin the game. For now, users call a simple REST API run by the house to
send it's next moves. This will be replaced with a Whisper implementation in the
near future. Each game turn now makes use of hashes from the 
chain of hashes generated initially, each turn will also have a corresponding nonce 
denoting the current turn count. 

When the user 'spins' on the frontend, a JSON object is created based on the 
current state of the game with the following format

    {
          reelHash - reelHash from the house for this turn - finalReelHash if nonce == 1
          reel - empty if user and nonce == 1
          reelSeedHash - reelSeedHash from the house for this turn - finalReelSeedHash if nonce == 1
          prevReelSeedHash - empty if user & nonce == 1
          userHash - finalUserHash if nonce == 1
          prevUserHash - hash to obtain userHash
          nonce - turn number - increments by 1 for every user turn
          userBalance - initialDeposit if nonce == 1
          houseBalance - initialDeposit if nonce == 1
          betSize - betSize for this turn, determined by user
          sign - signed spin object
    }
    
This is sent to a House API endpoint that accepts the next spin for an active channel.
The house verifies the properties of the object sent along with a signed string denoting 
the spin object to ensure the address associated with the channel is 
performing a spin. 

If the hashes are pre-images of the hashes sent in the previous turn
and the signed message returns the correct address after running it through
**ecrecover()**, the house uses the last move seed and reel hashes along with 
the contract address hash as parameters to generate the next reel and update 
balances for both parties before sending them within the response body.

The spin data returned to the user is then verified in a similar manner to verify whether
the data matches the previous hashes sent by the house, as well as the current nonce.

If the user loses state at any point of time due to a disconnection or inactivity, 
for the moment the house will store an AES-256 encrypted string of the last spin
which's submitted by the user that can only be decrypted using the AES key
created using the private key of the user's address. In the near future, this can
be stored using swarm instead.